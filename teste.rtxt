{
    "content": "import tkinter as tk\nfrom tkinter import ttk  # para o Combobox\nimport json  # para permitir usar persist\u00eancia de dados entre sess\u00f5es\nfrom tkinter.filedialog import asksaveasfilename, askopenfilename\nfrom tkinter.messagebox import askyesnocancel\n# Destaque de sintaxe\nfrom idlelib.colorizer import ColorDelegator, color_config\nfrom idlelib.percolator import Percolator\nfrom idlelib.undo import UndoDelegator\n\n\nclass GestorTemas:\n    \"\"\"Gerencia temas claro e escuro para o editor.\"\"\" \n    TEMAS = {\n        \"claro\": {\n            \"bg\": \"white\",\n            \"fg\": \"black\",\n            \"select_bg\": \"lightblue\",\n            \"line_bg\": \"lightgray\",\n            \"line_fg\": \"black\"\n        },\n        \"escuro\": {\n            \"bg\": \"#2b2b2b\",\n            \"fg\": \"white\",\n            \"select_bg\": \"#404040\",\n            \"line_bg\": \"#404040\",\n            \"line_fg\": \"lightgray\"\n        }\n    }\n    \n    def __init__(self, area_texto):\n        self.area_texto = area_texto\n        self.tema_atual = \"claro\"\n    \n    def aplicar_tema(self, tema):\n        \"\"\"Aplica o tema especificado \u00e0 \u00e1rea de texto.\"\"\"\n        if tema not in self.TEMAS:\n            return\n        \n        cores = self.TEMAS[tema]\n        self.tema_atual = tema\n        \n        # Aplicar cores ao texto principal\n        self.area_texto.texto.config(\n            bg=cores[\"bg\"],\n            fg=cores[\"fg\"],\n            selectbackground=cores[\"select_bg\"],\n            insertbackground=cores[\"fg\"]\n        )\n        \n        # Aplicar cores aos n\u00fameros de linha\n        self.area_texto.numeros_linha.config(\n            bg=cores[\"line_bg\"],\n            fg=cores[\"line_fg\"]\n        )\n        \n        # Configurar cores de syntax highlighting baseadas no tema\n        if tema == \"escuro\":\n            self.area_texto.texto.tag_configure(\"COMMENT\", foreground=\"#6A9955\")\n            self.area_texto.texto.tag_configure(\"STRING\", foreground=\"#CE9178\")\n            self.area_texto.texto.tag_configure(\"DEFINITION\", foreground=\"#4EC9B0\")\n            self.area_texto.texto.tag_configure(\"BUILTIN\", foreground=\"#569CD6\")\n        else:\n            self.area_texto.texto.tag_configure(\"COMMENT\", foreground=\"grey\")\n            self.area_texto.texto.tag_configure(\"STRING\", foreground=\"orange\")\n            self.area_texto.texto.tag_configure(\"DEFINITION\", foreground=\"green\")\n            self.area_texto.texto.tag_configure(\"BUILTIN\", foreground=\"green\")\n\n\nclass AreaTexto:\n    \"\"\"Gerencia a \u00e1rea de texto principal e n\u00fameros de linha.\"\"\"\n    \n    def __init__(self, parent, familia_fonte=\"Arial\", tamanho_fonte=12):\n        self.parent = parent\n        self.familia_fonte = familia_fonte\n        self.tamanho_fonte = tamanho_fonte\n        # vari\u00e1vel para controlar se os n\u00fameros de linha est\u00e3o vis\u00edveis\n        self.mostrar_numeros_linha = tk.BooleanVar()\n        # Definir o n\u00famero de espa\u00e7os para a tecla TAB\n        self.tab_width = 4\n        self._configurar_area_texto()\n        self._configurar_realce_sintaxe()\n    \n    def _configurar_area_texto(self):\n        # Frame para conter o widget de n\u00fameros de linha e o texto\n        self.frame = tk.Frame(self.parent)\n        self.frame.rowconfigure(0, weight=1)\n        # Coluna do texto principal \u00e9 expans\u00edvel\n        self.frame.columnconfigure(1, weight=1)\n        \n        # Frame para conter os n\u00fameros de linha com uma largura fixa\n        self.frame_numeros_wrapper = tk.Frame(self.frame, width=50)\n        self.frame_numeros_wrapper.grid(row=0, column=0, sticky=\"ns\")\n        # Impede que o widget interno redimensione este frame\n        self.frame_numeros_wrapper.grid_propagate(False)\n        \n        # Widget para n\u00fameros de linha\n        self.numeros_linha = tk.Text(\n            self.frame_numeros_wrapper,\n            width=4, padx=3, takefocus=0, border=0,\n            state='disabled', wrap='none',\n            font=(self.familia_fonte, self.tamanho_fonte, \"bold\"),\n            bg='lightgray', fg='black'\n        )\n        self.numeros_linha.pack(fill=\"both\", expand=True)\n        \n        # Widget principal de texto\n        self.texto = tk.Text(\n            self.frame, \n            font=(self.familia_fonte, self.tamanho_fonte, \"bold\"),\n            wrap=tk.WORD, fg=\"black\", undo=True\n        )\n        self.texto.grid(row=0, column=1, sticky=\"nsew\")\n        \n        # Adicionar Scrollbar vertical\n        self.scrollbar_texto = tk.Scrollbar(\n            self.frame, orient=tk.VERTICAL, command=self.texto.yview)\n        self.scrollbar_texto.grid(row=0, column=2, sticky=\"ns\")\n        \n        self._configurar_scroll_sincronizado()\n    \n    de _configurar_realce_sintaxe(self):\n        ########## REALCE DE SINTAXE E GESTOR DE UNDO/REDO ##########\n        # Configurar o Percolator para interceptar modifica\u00e7\u00f5es de texto\n        self.percolator = Percolator(self.texto)\n        \n        # Adicionar o gestor de Undo/Redo\n        self.undo = UndoDelegator()\n        self.percolator.insertfilter(self.undo)\n        \n        # Adicionar o ColorDelegator para syntax highlighting\n        self.color = ColorDele  gator()\n        self.percolator.insertfil  self.c  or)\n        \n        # Aplicar as cores do tema padr\u00e3o ao widget de texto\n        color_config(self.texto)\n        \n        # Substituir as cores\n        self.texto.tag_configure(\"COMMENT\", foreground=\"grey\")\n        self.texto.tag_configure(\"STRING\", foreground=\"orange\")\n        self.texto.tag_configure(\"DEFINITION\", foreground=\"green\")\n        self.texto.tag_configure(\"BUILTIN\", foreground=\"green\")\n    \n    def _configurar_scroll_sincronizado(self):\n        \"\"\"Configura a sincroniza\u00e7\u00e3o de scroll entre o texto principal e os n\u00fameros de linha\"\"\"\n        def _on_text_scroll_combined(*args):\n            # Atualiza a scrollbar\n            self.scrollbar_texto.set(*args)\n            # Sincroniza os n\u00fameros de linha, se vis\u00edveis\n            if self.mostrar_numeros_linha.get():\n                self.numeros_linha.yview_moveto(args[0])\n        \n        self.texto.config(yscrollcommand=_on_text_scroll_combined)\n    \n    def atualizar_numeros_linha(self):\n        \"\"\"Atualiza os n\u00fameros de linha de forma eficiente.\"\"\"\n        if not self.mostrar_numeros_linha.get():\n            return\n        \n        # Guardar a posi\u00e7\u00e3o atual do scroll para restaurar depois\n        scroll_pos = self.texto.yview()\n        \n        try:\n            # O \u00edndice 'end-1c' d\u00e1 a posi\u00e7\u00e3o do \u00faltimo caractere\n            linhas = int(self.texto.index(f\"{tk.END}-1c\").split('.')[0])\n        except tk.TclError:\n            linhas = 1  # Se o widget estiver vazio, ainda temos 1 linha\n        \n        # Gerar os n\u00fameros de linha\n        numeros = '\\n'.join(str(i) for i in range(1, linhas + 1))\n        \n        # Atualizar o widget de n\u00fameros de linha e restaurar o scroll\n        self.numeros_linha.config(state='normal')\n        self.numeros_linha.delete(1.0, tk.END)\n        self.numeros_linha.insert(1.0, numeros)\n        self.numeros_linha.config(state='disabled')\n        self.numeros_linha.yview_moveto(scroll_pos[0])\n    \n    def alternar_numeros_linha(self):\n        \"\"\"Mostra ou oculta os n\u00fameros de linha baseado no estado do checkbox\"\"\"\n        if self.mostrar_numeros_linha.get():\n            self.numeros_linha.pack(fill=\"both\", expand=True)\n            self.atualizar_numeros_linha()\n        else:\n            self.numeros_linha.pack_forget()\n\n\nclass PainelFerramentas:\n    \"\"\"Gerencia o painel de ferramentas lateral.\"\"\"\n    \n    def __init__(self, parent, area_texto, gestor_ficheiros):\n        self.parent = parent\n        self.area_texto = area_texto\n        self.gestor_ficheiros = gestor_ficheiros\n        self._configurar_painel()\n    \n    def _configurar_painel(self):\n        self.frame = tk.Frame(self.parent, relief=tk.RAISED, bd=2)\n        \n        # dicion\u00e1rio para criar os bot\u00f5es\n        botoes = {\n            \"Novo\": self.gestor_ficheiros.novo_ficheiro,\n            \"Abrir\": self.gestor_ficheiros.abrir_ficheiro,\n            \"Gravar\": self.gestor_ficheiros.gravar_ficheiro,\n            \"Gravar Como\": self.gestor_ficheiros.gravar_como,\n        }\n        \n        # cria\u00e7\u00e3o dos bot\u00f5es utilizando o dicion\u00e1rio\n        for i, (texto_botao, comando) in enumerate(botoes.items()):\n            botao = tk.Button(self.frame, text=texto_botao, command=comando)\n            botao.grid(row=i, column=0, padx=5, pady=5, sticky=\"ew\")\n        \n        # Checkbox para mostrar/ocultar n\u00fameros de linha\n        checkbox_numeros = tk.Checkbutton(\n            self.frame, text=\"N\u00fameros de Linha\",\n            variable=self.area_texto.mostrar_numeros_linha,\n            command=self.area_texto.alternar_numeros_linha\n        )\n        checkbox_numeros.grid(row=len(botoes), column=0, padx=5, pady=5, sticky=\"w\")\n        \n        # Controles de formata\u00e7\u00e3o\n        self._configurar_controles_formatacao(len(botoes) + 1)\n        \n        # Gestor de temas\n        self.gestor_temas = GestorTemas(self.area_texto)\n        # Adicionar refer\u00eancia ao gestor de temas na \u00e1rea de texto\n        self.area_texto.gestor_temas = self.gestor_temas\n        \n        # Controles de tema\n        self._configurar_controles_tema(l  n(botoes) + 7)\n    \n    def _configurar_controles_formatacao(self, linha_inicial):\n        # Label e sele\u00e7\u00e3o de cor do texto\n        label_cor = tk.Label(self.frame, text=\"Cor do Texto:\")\n        label_cor.grid(row=linha_inicial, column=0, padx=5, pady=(10, 0), sticky=\"w\")\n        \n        # Frame para os bot\u00f5es de cor\n        frame_cores = tk.Frame(self.frame)\n        frame_cores.grid(row=linha_inicial + 1, column=0, padx=5, pady=5, sticky=\"w\")\n        \n        # Dicion\u00e1rio com cores dispon\u00edveis\n        self.cores_disponiveis = {\n            \"Preto\": \"black\", \"Azul\": \"blue\", \"Vermelho\": \"red\",\n            \"Verde\": \"green\", \"Roxo\": \"purple\", \"Laranja\": \"orange\"\n        }\n        \n        # Pre-configurar tags de cor para o texto\n        for cor in self.cores_disponiveis.values():\n            self.area_texto.texto.tag_config(f\"color_{cor}\", foreground=cor)\n        \n        # Criar bot\u00f5es para cada cor\n        for i, (nome_cor, valor_cor) in enumerate(self.cores_disponiveis.items()):\n            botao_cor = tk.Button(\n                frame_cores, text=nome_cor, bg=valor_cor, width=8,\n                fg=\"white\" if valor_cor in [\"black\", \"blue\", \"purple\"] else \"black\",\n                command=lambda cor=valor_cor: self._alterar_cor_texto(cor)\n            )\n            # Organizar em 2 colunas\n            botao_cor.grid(row=i // 2, column=i % 2, padx=2, pady=2)\n        \n        # Label e slider para o tamanho da fonte\n        label_tamanho_fonte = tk.Label(self.frame, text=\"Tamanho da Fonte:\")\n        label_tamanho_fonte.grid(row=linha_inicial + 2, column=0, padx=5, pady=(10, 0), sticky=\"w\")\n        \n        # Vari\u00e1vel para controlar o tamanho da fonte\n        self.tamanho_fonte_var = tk.IntVar(value=12)\n        \n        slider_tamanho_fonte = tk.Scale(\n            self.frame, from_=10, to=22, orient=tk.HORIZONTAL,\n            variable=self.tamanho_fonte_var,\n            command=self._alterar_tamanho_fonte\n        )\n        slider_tamanho_fonte.grid(row=linha_inicial + 3, column=0, padx=5, pady=5, sticky=\"ew\")\n        \n        # Label e combobox para a fam\u00edlia da fonte\n        label_familia_fonte = tk.Label(self.frame, text=\"Fam\u00edlia da Fonte:\")\n        label_familia_fonte.grid(row=linha_inicial + 4, column=0, padx=5, pady=(10, 0), sticky=\"w\")\n        \n        # Op\u00e7\u00f5es de fam\u00edlia de fonte dispon\u00edveis\n        familias_fonte_disponiveis = [\"Arial\", \"Times New Roman\", \"Courier New\"]\n        \n        self.combobox_familia_fonte = ttk.Combobox(\n            self.frame, values=familias_fonte_disponiveis,\n            state=\"readonly\", width=15  # impede edi\u00e7\u00e3o manual\n        )\n        self.combobox_familia_fonte.set(self.area_texto.familia_fonte)\n        self.combobox_familia_fonte.bind(\"<<ComboboxSelected>>\", self._alterar_familia_fonte)\n        self.combobox_familia_fonte.grid(row=linha_inicial + 5, column=0, padx=5, pady=5, sticky=\"ew\")\n    \n    def _alterar_cor_texto(self, nova_cor):\n        \"\"\"Altera a cor do texto selecionado no editor.\"\"\"\n        try:\n            # Obter os \u00edndices do texto selecionado\n            start, end = self.area_texto.texto.tag_ranges(tk.SEL)\n        except ValueError:\n            return  # Nenhum texto selecionado\n        \n        # Remover tags de cor existentes da sele\u00e7\u00e3o\n        for cor in self.cores_disponiveis.values():\n            self.area_texto.texto.tag_remove(f\"color_{cor}\", start, end)\n        \n        # Adicionar a nova tag de cor \u00e0 sele\u00e7\u00e3o\n        if nova_cor != \"black\":\n            self.area_texto.texto.tag_add(f\"color_{nova_cor}\", start, end)\n    \n    def _alterar_tamanho_fonte(self, novo_tamanho_str):\n        \"\"\"Altera o tamanho da fonte no editor e nos n\u00fameros de linha.\"\"\"\n        novo_tamanho = int(novo_tamanho_str)\n        nova_fonte = (self.area_texto.familia_fonte, novo_tamanho, \"bold\")\n        \n        self.area_texto.texto.config(font=nova_fonte)\n        self.area_texto.numeros_linha.config(font=nova_fonte)\n        self.area_texto.atualizar_numeros_linha()\n    \n    def _alterar_familia_fonte(self, event=None):\n        \"\"\"Altera a fam\u00edlia da fonte no editor e nos n\u00fameros de linha.\"\"\"\n        nova_familia = self.combobox_familia_fonte.get()\n        self.area_texto.familia_fonte = nova_familia\n        \n        nova_fonte = (nova_familia, self.tamanho_fonte_var.get(), \"bold\")\n        self.area_texto.texto.config(font=nova_fonte)\n        self.area_texto.numeros_linha.config(font=nova_fonte)\n        self.area_texto.atualizar_numeros_linha()\n    \n    def _configurar_controles_tema(self, linha_inicial):\n        \"\"\"Configura os controles de tema claro/escuro.\"\"\"\n        # Label para tema\n        label_tema = tk.Label(self.frame, text=\"Tema:\")\n        label_tema.grid(row=linha_inicial, column=0, padx=5, pady=(10, 0), sticky=\"w\")\n        \n        # Vari\u00e1vel para controlar o tema\n        self.tema_var = tk.StringVar(value=\"claro\")\n        \n        # Radiobuttons para tema\n        radio_claro = tk.Radiobutton(\n            self.frame, text=\"Claro\", variable=self.tema_var, value=\"claro\",\n            command=lambda: self.gestor_temas.aplicar_tema(\"claro\")\n        )\n        radio_claro.grid(row=linha_inicial + 1, column=0, padx=5, pady=2, sticky=\"w\")\n        \n        radio_escuro = tk.Radiobutton(\n            self.frame, text=\"Escuro\", variable=self.tema_var, value=\"escuro\",\n            command=lambda: self.gestor_temas.aplicar_tema(\"escuro\")\n        )\n        radio_escuro.grid(row=linha_inicial + 2, column=0, padx=5, pady=2, sticky=\"w\")\n\n\nclass PainelPesquisa:\n    \"\"\"Gerencia o painel de pesquisa.\"\"\"\n    def __init__(self, parent, area_texto):\n        self.parent = parent\n        self.area_texto = area_texto\n        # Lista para armazenar informa\u00e7\u00f5es dos resultados\n        self.resultados_pesquisa = []\n        self._configurar_painel()\n    \n    def _configurar_painel(self):\n        # Frame para o painel de pesquisa\n        self.frame = tk.Frame(self.parent, relief=tk.RAISED, bd=2)\n        \n        # Campo de pesquisa e bot\u00f5es\n        label_termo = tk.Label(self.frame, text=\"Pesquisar:\")\n        label_termo.grid(row=0, column=0, padx=(5, 2), pady=3, sticky=\"w\")\n        \n        self.entry_pesquisa = tk.Entry(self.frame, width=8)\n        self.entry_pesquisa.grid(row=0, column=1, padx=2, pady=3)\n        self.entry_pesquisa.bind(\"<Return>\", self.pesquisar_texto)\n        \n        btn_pesquisar = tk.Button(self.frame, text=\"Pesquisar\", command=self.pesquisar_texto)\n        btn_pesquisar.grid(row=0, column=2, padx=2, pady=3)\n        \n        btn_limpar = tk.Button(self.frame, text=\"Limpar\", command=self.limpar_pesquisa)\n        btn_limpar.grid(row=0, column=3, padx=(2, 5), pady=3)\n        \n        # Listbox com resultados\n        frame_listbox = tk.Frame(self.frame)\n        frame_listbox.grid(row=1, column=0, columnspan=4, padx=5, pady=(3, 5), sticky=\"ew\")\n        \n        self.listbox_resultados = tk.Listbox(frame_listbox, height=5)\n        self.listbox_resultados.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        \n        # Scrollbar para a listbox\n        scrollbar_listbox = tk.Scrollbar(frame_listbox, orient=tk.VERTICAL, command=self.listbox_resultados.yview)\n        scrollbar_listbox.pack(side=tk.RIGHT, fill=tk.Y)\n        self.listbox_resultados.config(yscrollcommand=scrollbar_listbox.set)\n        \n        # Bind para duplo clique na listbox\n        self.listbox_resultados.bind(\"<Double-Button-1>\", self.ir_para_resultado)\n        \n        # Configurar expans\u00e3o do frame de pesquisa\n        self.frame.columnconfigure(1, weight=0)\n    \n    def pesquisar_texto(self, event=None):\n        \"\"\"Pesquisa o texto no editor e mostra os resultados na listbox.\"\"\"\n        termo_pesquisa = self.entry_pesquisa.get().strip()\n        if not termo_pesquisa:\n            return\n        \n        # Limpar resultados anteriores\n        self.listbox_resultados.delete(0, tk.END)\n        self.resultados_pesquisa.clear()\n        \n        # Remover highlights anteriores\n        self.area_texto.texto.tag_remove(\"search_highlight\", \"1.0\", tk.END)\n        \n        # Obter todo o conte\u00fado do texto\n        conteudo = self.area_texto.texto.get(\"1.0\", tk.END)\n        linhas = conteudo.split('\\n')\n        \n        # Pesquisar em cada linha\n        for num_linha, linha in enumerate(linhas, 1):\n            if termo_pesquisa.lower() in linha.lower():\n                pos = linha.lower().find(termo_pesquisa.lower())\n                linha_pos = f\"{num_linha}.{pos}\"\n                fim_pos = f\"{num_linha}.{pos + len(termo_pesquisa)}\"\n                \n                # Adicionar highlight\n                self.area_texto.texto.tag_add(\"search_highlight\", linha_pos, fim_pos)\n                \n                # Preparar texto para mostrar na listbox (limitado a 60 caracteres)\n                contexto = linha.strip()\n                if len(contexto) > 60:\n                    contexto = contexto[:60] + \"...\"\n                \n                # Adicionar \u00e0 listbox\n                resultado_texto = f\"Linha {num_linha}: {contexto}\"\n                self.listbox_resultados.insert(tk.END, resultado_texto)\n                \n                # Armazenar informa\u00e7\u00f5es do resultado\n                self.resultados_pesquisa.append({\n                    'linha': num_linha, 'coluna': pos,\n                    'posicao': linha_pos, 'fim_posicao': fim_pos\n                })\n        \n        # Configurar cor do highlight baseada no tema atual\n        if hasattr(self.area_texto, 'gestor_temas') and self.area_texto.gestor_temas.tema_atual == \"escuro\":\n            self.area_texto.texto.tag_config(\"search_highlight\", background=\"#404040\", foreground=\"yellow\")\n        else:\n            self.area_texto.texto.tag_config(\"search_highlight\", background=\"yellow\", foreground=\"black\")\n        \n        # Mostrar n\u00famero de resultados\n        if len(self.resultados_pesquisa) == 0:\n            self.listbox_resultados.insert(tk.END, \"Nenhum resultado encontrado\")\n        elif self.resultados_pesquisa:\n            # Ir para o primeiro resultado\n            primeiro_resultado = self.resultados_pesquisa[0]\n            self.area_texto.texto.see(primeiro_resultado['posicao'])\n    \n    def limpar_pesquisa(self):\n        \"\"\"Limpa os resultados da pesquisa e remove os highlights.\"\"\"\n        self.entry_pesquisa.delete(0, tk.END)\n        self.listbox_resultados.delete(0, tk.END)\n        self.resultados_pesquisa.clear()\n        self.area_texto.texto.tag_remove(\"search_highlight\", \"1.0\", tk.END)\n    \n    def ir_para_resultado(self, event=None):\n        \"\"\"Vai para o resultado selecionado na listbox.\"\"\"\n        selecao = self.listbox_resultados.curselection()\n        if not selecao or selecao[0] >= len(self.resultados_pesquisa):\n            return\n        \n        resultado = self.resultados_pesquisa[selecao[0]]\n        \n        # Ir para a posi\u00e7\u00e3o do resultado\n        self.area_texto.texto.see(resultado['posicao'])\n        self.area_texto.texto.mark_set(tk.INSERT, resultado['posicao'])\n        \n        # Selecionar o texto encontrado\n        self.area_texto.texto.tag_remove(tk.SEL, \"1.0\", tk.END)\n        self.area_texto.texto.tag_add(tk.SEL, resultado['posicao'], resultado['fim_posicao'])\n        \n        # Focar no texto\n        self.area_texto.texto.focus_set()\n    \n    def focar_pesquisa(self, event=None):\n        \"\"\"Foca no campo de pesquisa quando Ctrl+F \u00e9 pressionado.\"\"\"\n        self.entry_pesquisa.focus_set()\n        self.entry_pesquisa.select_range(0, tk.END)\n\n\nclass GestorFicheiros:\n    \"\"\"Gerencia opera\u00e7\u00f5es de ficheiro.\"\"\"\n    \n    def __init__(self, area_texto, callback_titulo):\n        self.area_texto = area_texto\n        self.callback_titulo = callback_titulo\n        # A vari\u00e1vel para armazenar o caminho do ficheiro aberto\n        self.caminho_ficheiro = None\n        # inicia a vari\u00e1vel como \"texto sem modifica\u00e7\u00f5es\"\n        self.modificado = False\n    \n    def novo_ficheiro(self, event=None):\n        if not self._verificar_modificacoes():\n            return\n        \n        self.area_texto.texto.delete(1.0, tk.END)\n        self.caminho_ficheiro = None\n        self.modificado = False\n        self.area_texto.texto.edit_modified(False)\n        self.callback_titulo()\n        self.area_texto.atualizar_numeros_linha()\n    \n    def abrir_ficheiro(self, event=None):\n        if not self._verificar_modificacoes():\n            return\n        \n        caminho = askopenfilename(\n            # Adicionar o novo tipo de ficheiro e manter os antigos\n            filetypes=[\n                (\"Ficheiro de Texto Formatado\", \"*.rtxt\"),\n                (\"Ficheiros de texto\", \"*.txt\"),\n                (\"Todos os Ficheiros\", \"*.*\")\n            ]\n        )\n        if not caminho:\n            return\n        \n        conteudo_formatado = None\n        try:\n            with open(caminho, \"r\", encoding='utf-8') as fich:\n                # Tentamos ler como JSON primeiro, que \u00e9 o nosso formato com estilos\n                conteudo_formatado = json.load(fich)\n        except (json.JSONDecodeError, UnicodeDecodeError):\n            # Se falhar, n\u00e3o \u00e9 um JSON v\u00e1lido. Tentamos ler como texto simples.\n            try:\n                with open(caminho, \"r\", encoding='utf-8') as fich:\n                    conteudo_simples = fich.read()\n                # Criamos uma estrutura compat\u00edvel para o resto da fun\u00e7\u00e3o\n                conteudo_formatado = {\"content\": conteudo_simples, \"tags\": []}\n            except Exception as e:\n                tk.messagebox.showerror(\"Erro ao Abrir\", f\"N\u00e3o foi poss\u00edvel ler o ficheiro:\\n{e}\")\n                return\n        except Exception as e:\n            tk.messagebox.showerror(\"Erro ao Abrir\", f\"Ocorreu um erro inesperado ao abrir o ficheiro:\\n{e}\")\n            return\n        \n        self.area_texto.texto.delete(1.0, tk.END)\n        # Inserir o conte\u00fado de texto\n        self.area_texto.texto.insert(tk.END, conteudo_formatado.get('content', ''))\n        \n        # Aplicar as tags de formata\u00e7\u00e3o guardadas\n        if 'tags' in conteudo_formatado:\n            for tag in conteudo_formatado['tags']:\n                self.area_texto.texto.tag_add(tag['name'], tag['start'], tag['end'])\n        \n        self.caminho_ficheiro = caminho\n        self.modificado = False\n        self.area_texto.texto.edit_modified(False)\n        self.callback_titulo()\n        self.area_texto.atualizar_numeros_linha()\n    \n    def gravar_ficheiro(self, event=None):\n        if not self.caminho_ficheiro:\n            return self.gravar_como()\n        \n        try:\n            # Se for um ficheiro .txt, gravamos como texto simples para compatibilidade\n            if self.caminho_ficheiro.endswith(\".txt\"):\n                conteudo = self.area_texto.texto.get(1.0, \"end-1c\")\n                with open(self.caminho_ficheiro, \"w\", encoding='utf-8') as fich:\n                    fich.write(conteudo)\n            else:  # Para .rtxt ou outros, guardamos com formata\u00e7\u00e3o (JSON)\n                conteudo = self.area_texto.texto.get(1.0, \"end-1c\")\n                tags = []\n                tag_names = self.area_texto.texto.tag_names()\n                for tag in tag_names:\n                    if tag == \"sel\":  # Ignorar a tag de sele\u00e7\u00e3o\n                        continue\n                    ranges = self.area_texto.texto.tag_ranges(tag)\n                    # tag_ranges devolve uma tupla de (start1, end1, start2, end2, ...)\n                    for i in range(0, len(ranges), 2):\n                        tags.append({\n                            \"name\": tag,\n                            \"start\": str(ranges[i]),\n                            \"end\": str(ranges[i+1])\n                        })\n                \n                dados_para_salvar = {\"content\": conteudo, \"tags\": tags}\n                with open(self.caminho_ficheiro, \"w\", encoding='utf-8') as fich:\n                    json.dump(dados_para_salvar, fich, indent=4)\n        except Exception as e:\n            tk.messagebox.showerror(\"Erro ao Gravar\", f\"N\u00e3o foi poss\u00edvel gravar o ficheiro:\\n{e}\")\n            return False\n        \n        self.modificado = False\n        self.area_texto.texto.edit_modified(False)\n        self.callback_titulo()\n        return True\n    \n    def gravar_como(self, event=None):\n        caminho = asksaveasfilename(\n            # Mudar a extens\u00e3o padr\u00e3o para o nosso novo formato\n            defaultextension=\".rtxt\",\n            # Adicionar o novo tipo de ficheiro e coloc\u00e1-lo como primeira op\u00e7\u00e3o\n            filetypes=[\n                (\"Ficheiro de Texto Formatado\", \"*.rtxt\"),\n                (\"Ficheiros de texto\", \"*.txt\"),\n                (\"Todos os Ficheiros\", \"*.*\")\n            ]\n        )\n        if not caminho:\n            return False\n        \n        self.caminho_ficheiro = caminho\n        # A l\u00f3gica de qual formato usar j\u00e1 est\u00e1 dentro de gravar_ficheiro()\n        return self.gravar_ficheiro()\n    \n    def _verificar_modificacoes(self):\n        # verifica se o texto foi modificado desde a \u00faltima vez que ele foi salvo\n        if not self.modificado:\n            return True\n        # se foi modificado, mostra uma mensagem perguntando se quer guardar as altera\u00e7\u00f5es\n        resposta = askyesnocancel(\n            title=\"Guardar Ficheiro?\",\n            message=\"O ficheiro atual tem altera\u00e7\u00f5es n\u00e3o guardadas. Quer guardar as altera\u00e7\u00f5es?\"\n        )\n        \n        if resposta is None:  # Cancelar\n            return False\n        elif resposta:  # Sim (Guardar)\n            return self.gravar_ficheiro()\n        else:  # N\u00e3o (N\u00e3o guardar)\n            return True\n\n\nclass EditorTexto:\n    \"\"\"Classe principal que coordena todos os componentes do editor.\"\"\"\n    \n    def __init__(self, master):\n        \"\"\"\n        Inicializa o editor de texto com arquitetura modular.\n        Configura a janela principal e cria todos os componentes.\n        \n        Args:\n            master: Janela principal do Tkinter (tk.Tk ou tk.Toplevel)\n        \"\"\"\n        self.master = master\n        self.master.title(\"Sem T\u00edtulo - Editor de Texto\")\n        self._configurar_layout()\n        self._criar_componentes()\n        self._configurar_bindings()\n    \n    def _configurar_layout(self):\n        self.master.rowconfigure(0, minsize=300, weight=1)\n        # Linha para o painel de pesquisa\n        self.master.rowconfigure(1, minsize=180, weight=0)\n        self.master.columnconfigure(0, minsize=200, weight=0)  # Coluna dos bot\u00f5es\n        self.master.columnconfigure(1, minsize=600, weight=1)  # Coluna do texto\n    \n    def _criar_componentes(self):\n        # \u00c1rea de texto\n        self.area_texto = AreaTexto(self.master)\n        self.area_texto.frame.grid(row=0, column=1, sticky=\"nsew\")\n        \n        # Gestor de ficheiros\n        self.gestor_ficheiros = GestorFicheiros(self.area_texto, self._atualizar_titulo)\n        \n        # Painel de ferramentas\n        self.painel_ferramentas = PainelFerramentas(self.master, self.area_texto, self.gestor_ficheiros)\n        self.painel_ferramentas.frame.grid(row=0, column=0, sticky=\"ns\")\n        \n        # Painel de pesquisa\n        self.painel_pesquisa = PainelPesquisa(self.master, self.area_texto)\n        self.painel_pesquisa.frame.grid(row=1, column=1, sticky=\"ew\", padx=5, pady=(5, 10))\n    \n    def _configurar_bindings(self):\n        # funciona como um listener, que \u00e9 chamado sempre que ocorre uma mudan\u00e7a na caixa de texto\n        self.area_texto.texto.bind(\"<<Modified>>\", self._ao_modificar)\n        # Interceptar a tecla Tab para inserir espa\u00e7os\n        self.area_texto.texto.bind(\"<Tab>\", self._on_tab_key)\n        \n        # Atalhos de teclado\n        self.master.bind(\"<Control-n>\", self.gestor_ficheiros.novo_ficheiro)\n        self.master.bind(\"<Control-a>\", self.gestor_ficheiros.abrir_ficheiro)\n        self.master.bind(\"<Control-g>\", self.gestor_ficheiros.gravar_ficheiro)\n        self.master.bind(\"<Control-c>\", self.gestor_ficheiros.gravar_como)\n        self.master.bind(\"<Control-f>\", self.painel_pesquisa.focar_pesquisa)\n        \n        # Ligar os eventos de Undo/Redo do widget de texto ao nosso gestor de undo\n        self.area_texto.texto.bind(\"<<Undo>>\", self.area_texto.undo.undo_event)\n        self.area_texto.texto.bind(\"<<Redo>>\", self.area_texto.undo.redo_event)\n        \n        # WM_DELETE_WINDOW \u00e9 um evento que \u00e9 acionado quando o usu\u00e1rio tenta fechar a janela\n        self.master.protocol(\"WM_DELETE_WINDOW\", self._ao_fechar)\n    \n    def _ao_modificar(self, event=None):\n        # verifica se a flag de modifica\u00e7\u00e3o est\u00e1 ativada (== True)\n        if self.area_texto.texto.edit_modified():\n            # se sim, altera a vari\u00e1vel da aplica\u00e7\u00e3o para True\n            self.gestor_ficheiros.modificado = True\n            # e atualiza o t\u00edtulo da janela com um asterisco (*) no in\u00edcio do t\u00edtulo\n            self._atualizar_titulo()\n            # Atualiza os n\u00fameros de linha, pois o conte\u00fado mudou\n            self.area_texto.atualizar_numeros_linha()\n            # Faz o reset da flag interna de modificado\n            self.area_texto.texto.edit_modified(False)\n    \n    def _on_tab_key(self, event=None):\n        \"\"\"Insere um n\u00famero predefinido de espa\u00e7os em vez de um caractere de tabula\u00e7\u00e3o.\"\"\"\n        self.area_texto.texto.insert(tk.INSERT, \" \" * self.area_texto.tab_width)\n        # Impede o comportamento padr\u00e3o da tecla Tab\n        return \"break\"\n    \n    def _atualizar_titulo(self):\n        # obt\u00e9m o nome do ficheiro a partir do caminho completo\n        # se n\u00e3o houver caminho definido, usa \"Sem T\u00edtulo\"\n        nome_ficheiro = (self.gestor_ficheiros.caminho_ficheiro.split(\"/\")[-1] \n                        if self.gestor_ficheiros.caminho_ficheiro else \"Sem T\u00edtulo\")\n        # mostra um asterisco (*) no in\u00edcio do t\u00edtulo da janela se o texto tiver sido modificado\n        modificado_str = \"*\" if self.gestor_ficheiros.modificado else \"\"\n        self.master.title(f\"{modificado_str}{nome_ficheiro} - Editor de Texto\")\n    \n    def _ao_fechar(self):\n        # verifica se h\u00e1 modifica\u00e7\u00f5es n\u00e3o guardadas antes de fechar a janela\n        if self.gestor_ficheiros._verificar_modificacoes():\n            # Limpar o percolator para evitar erros ao fechar\n            self.area_texto.percolator.close()\n            # se n\u00e3o, fecha a janela\n            self.master.destroy()\n\n\ndef main():\n    janela = tk.Tk()\n    app = EditorTexto(janela)\n    janela.mainloop()\n\n\nif __name__ == \"__main__\":\n    main()",
    "tags": [
        {
            "name": "color_blue",
            "start": "1.0",
            "end": "9.38"
        }
    ]
}